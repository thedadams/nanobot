import"./DsnmJJEf.js";import{p as y,d as x,f as S,an as v,a2 as F,g as I,c as b,ao as h,aC as D,aD as W,i as c,a8 as l,aE as g,ad as u}from"./TV9P7kG6.js";import{s as $,r as E}from"./DJGld0fm.js";import{I as M,S as C,U as R,W as L}from"./CnB9Cxot.js";import{s as j}from"./Ctz0fIT4.js";function Q(d,t){y(t,!0);/**
 * @license @lucide/svelte v0.540.0 - ISC
 *
 * ISC License
 *
 * Copyright (c) for portions of Lucide are held by Cole Bemis 2013-2023 as part of Feather (MIT). All other copyright (c) for Lucide are held by Lucide Contributors 2025.
 *
 * Permission to use, copy, modify, and/or distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 * ---
 *
 * The MIT License (MIT) (for portions derived from Feather)
 *
 * Copyright (c) 2013-2023 Cole Bemis
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 */let e=E(t,["$$slots","$$events","$$legacy"]);const a=[["path",{d:"M12 8V4H8"}],["rect",{width:"16",height:"12",x:"4",y:"8",rx:"2"}],["path",{d:"M2 14h2"}],["path",{d:"M20 14h2"}],["path",{d:"M15 13v2"}],["path",{d:"M9 13v2"}]];M(d,$({name:"bot"},()=>e,{get iconNode(){return a},children:(i,s)=>{var o=x(),r=S(o);v(r,()=>t.children??F),I(i,o)},$$slots:{default:!0}})),b()}function X(d,t){y(t,!0);/**
 * @license @lucide/svelte v0.540.0 - ISC
 *
 * ISC License
 *
 * Copyright (c) for portions of Lucide are held by Cole Bemis 2013-2023 as part of Feather (MIT). All other copyright (c) for Lucide are held by Lucide Contributors 2025.
 *
 * Permission to use, copy, modify, and/or distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 * ---
 *
 * The MIT License (MIT) (for portions derived from Feather)
 *
 * Copyright (c) 2013-2023 Cole Bemis
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 */let e=E(t,["$$slots","$$events","$$legacy"]);const a=[["rect",{x:"3",y:"5",width:"6",height:"6",rx:"1"}],["path",{d:"m3 17 2 2 4-4"}],["path",{d:"M13 6h8"}],["path",{d:"M13 12h8"}],["path",{d:"M13 18h8"}]];M(d,$({name:"list-todo"},()=>e,{get iconNode(){return a},children:(i,s)=>{var o=x(),r=S(o);v(r,()=>t.children??F),I(i,o)},$$slots:{default:!0}})),b()}function Z(d,t){y(t,!0);/**
 * @license @lucide/svelte v0.540.0 - ISC
 *
 * ISC License
 *
 * Copyright (c) for portions of Lucide are held by Cole Bemis 2013-2023 as part of Feather (MIT). All other copyright (c) for Lucide are held by Lucide Contributors 2025.
 *
 * Permission to use, copy, modify, and/or distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 * ---
 *
 * The MIT License (MIT) (for portions derived from Feather)
 *
 * Copyright (c) 2013-2023 Cole Bemis
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 */let e=E(t,["$$slots","$$events","$$legacy"]);const a=[["path",{d:"M5 12h14"}],["path",{d:"M12 5v14"}]];M(d,$({name:"plus"},()=>e,{get iconNode(){return a},children:(i,s)=>{var o=x(),r=S(o);v(r,()=>t.children??F),I(i,o)},$$slots:{default:!0}})),b()}const z=()=>{const d=j;return{page:{subscribe:d.page.subscribe},navigating:{subscribe:d.navigating.subscribe},updated:d.updated}},tt={subscribe(d){return z().page.subscribe(d)}};var A=["forEach","isDisjointFrom","isSubsetOf","isSupersetOf"],J=["difference","intersection","symmetricDifference","union"],P=!1;class k extends Set{#s=new Map;#t=h(0);#e=h(0);#a=W||-1;constructor(t){if(super(),t){for(var e of t)super.add(e);this.#e.v=super.size}P||this.#o()}#i(t){return W===this.#a?h(t):D(t)}#o(){P=!0;var t=k.prototype,e=Set.prototype;for(const a of A)t[a]=function(...i){return c(this.#t),e[a].apply(this,i)};for(const a of J)t[a]=function(...i){c(this.#t);var s=e[a].apply(this,i);return new k(s)}}has(t){var e=super.has(t),a=this.#s,i=a.get(t);if(i===void 0){if(!e)return c(this.#t),!1;i=this.#i(!0),a.set(t,i)}return c(i),e}add(t){return super.has(t)||(super.add(t),l(this.#e,super.size),g(this.#t)),this}delete(t){var e=super.delete(t),a=this.#s,i=a.get(t);return i!==void 0&&(a.delete(t),l(i,!1)),e&&(l(this.#e,super.size),g(this.#t)),e}clear(){if(super.size!==0){super.clear();var t=this.#s;for(var e of t.values())l(e,!1);t.clear(),l(this.#e,0),g(this.#t)}}keys(){return this.values()}values(){return c(this.#t),super.values()}entries(){return c(this.#t),super.entries()}[Symbol.iterator](){return this.keys()}get size(){return c(this.#e)}}const _="application/vnd.nanobot.task+json",N="application/vnd.nanobot.agent+json",T="application/vnd.nanobot.conversation+json",U="application/vnd.nanobot.flowchart+json";class Y{workspaceId;#s=h(u([]));get items(){return c(this.#s)}set items(t){l(this.#s,t,!0)}#t=h(u([]));get files(){return c(this.#t)}set files(t){l(this.#t,t,!0)}#e=h(u([]));get taskFlowcharts(){return c(this.#e)}set taskFlowcharts(t){l(this.#e,t,!0)}#a=h(u(new k));get expandedSections(){return c(this.#a)}set expandedSections(t){l(this.#a,t,!0)}#i=h(u(new k));get expandedFilePaths(){return c(this.#i)}set expandedFilePaths(t){l(this.#i,t,!0)}#o=h(!1);get isLoading(){return c(this.#o)}set isLoading(t){l(this.#o,t,!0)}client;unwatchResources;constructor(t){this.workspaceId=t,this.client=new C({path:`${R}&workspace=${t}`}),this.loadExpandedState()}classifyResource(t){if(!t.uri.startsWith("workspace://"))return null;switch(t.mimeType){case _:return{type:"item",data:{id:t.uri.replace("workspace://tasks/",""),workspaceId:this.workspaceId,type:"task",title:t.name||"Untitled Task",created:t.annotations?.lastModified||new Date().toISOString(),status:"active"}};case N:return{type:"item",data:{id:t.uri.replace("workspace://agents/",""),workspaceId:this.workspaceId,type:"agent",title:t.name||"Untitled Agent",created:t.annotations?.lastModified||new Date().toISOString(),status:"active"}};case T:return{type:"item",data:{id:t.uri.replace("workspace://conversations/",""),workspaceId:this.workspaceId,type:"conversation",title:t.name||"Untitled Conversation",created:t.annotations?.lastModified||new Date().toISOString(),status:"active"}};case U:return null;default:if(t.uri.startsWith("workspace://files/")){const e=t.uri.replace("workspace://files/","");return{type:"file",data:{id:e,workspaceId:this.workspaceId,path:e,created:t.annotations?.lastModified||new Date().toISOString(),size:t.size||0,mimeType:t.mimeType}}}return null}}async updateSingleResource(t){const e=t.uri,a=!e.startsWith("workspace://");let i;if(a){const r=(await this.client.listResources({prefix:e})).resources?.find(n=>n.uri===e);if(!r)return;i=r}else i={uri:t.uri,mimeType:t.mimeType,name:"",annotations:{lastModified:new Date().toISOString()}};const s=this.classifyResource(i);if(s){if(s.type==="item"){const o=this.items.findIndex(r=>r.id===s.data.id);o>=0?((!s.data.title||s.data.title==="Untitled Task"||s.data.title==="Untitled Agent"||s.data.title==="Untitled Conversation")&&(s.data.title=this.items[o].title),this.items[o]=s.data,this.items=[...this.items]):this.items=[...this.items,s.data]}else if(s.type==="file"){const o=this.files.findIndex(r=>r.id===s.data.id);o>=0?(this.files[o]=s.data,this.files=[...this.files]):this.files=[...this.files,s.data]}}}async load(){this.isLoading=!0;try{const t=await this.client.listResources({prefix:"workspace://"});if(!t.resources||t.resources.length===0)this.items=[],this.files=[],this.taskFlowcharts=[];else{const e=[],a=[];for(const i of t.resources){const s=this.classifyResource(i);s&&(s.type==="item"?e.push(s.data):s.type==="file"&&a.push(s.data))}this.items=e,this.files=a,this.taskFlowcharts=[]}this.unwatchResources=this.client.watchResource("workspace://",e=>{this.updateSingleResource(e)})}catch(t){console.error("Failed to load workspace items:",t),this.items=[],this.files=[],this.taskFlowcharts=[]}finally{this.isLoading=!1}}getTaskFlowchart(t){return this.taskFlowcharts.find(e=>e.taskId===t)}async toggleNodeCompletion(t,e){const a=this.taskFlowcharts.find(i=>i.taskId===t);if(a){const i=a.nodes.find(s=>s.id===e);i&&i.type!=="start"&&i.type!=="end"&&(i.completed=!i.completed,await this.updateFlowchart(t,a))}}async updateFlowchart(t,e){await this.client.callMCPTool("update_resource",{payload:{uri:`workspace://flowcharts/${t}`,text:JSON.stringify(e)}}),this.taskFlowcharts=[...this.taskFlowcharts]}async removeNodeAssignment(t,e,a,i){const s=this.taskFlowcharts.find(o=>o.taskId===t);if(s){const o=s.nodes.find(r=>r.id===e);if(o&&o[a]){const r=o[a],n=r.indexOf(i);n>-1&&(r.splice(n,1),await this.updateFlowchart(t,s))}}}async addNodeAssignment(t,e,a,i){const s=this.taskFlowcharts.find(o=>o.taskId===t);if(s){const o=s.nodes.find(r=>r.id===e);o&&(o[a]||(o[a]=[]),o[a].includes(i)||(o[a].push(i),await this.updateFlowchart(t,s)))}}async addEdge(t,e,a,i){const s=this.taskFlowcharts.find(o=>o.taskId===t);if(s){const o={id:`e${Date.now()}`,source:e,target:a,label:i};s.edges.push(o),await this.updateFlowchart(t,s)}}async createNode(t,e,a,i,s){const o=this.taskFlowcharts.find(r=>r.taskId===t);if(o){const r=`node-${Date.now()}`;let n={x:250,y:100};if(s){const w=o.nodes.find(p=>p.id===s);w&&(n={x:w.position.x,y:w.position.y+150})}else n={x:250,y:Math.max(...o.nodes.map(p=>p.position.y))+150};const f={id:r,type:e,label:a,content:i,position:n};return o.nodes.push(f),await this.updateFlowchart(t,o),r}throw new Error("Task flowchart not found")}async updateEdge(t,e,a){const i=this.taskFlowcharts.find(s=>s.taskId===t);if(i){const s=i.edges.find(o=>o.id===e);s&&(Object.assign(s,a),await this.updateFlowchart(t,i))}}async deleteEdge(t,e){const a=this.taskFlowcharts.find(i=>i.taskId===t);a&&(a.edges=a.edges.filter(i=>i.id!==e),await this.updateFlowchart(t,a))}async addNodeInput(t,e,a,i,s){const o=this.taskFlowcharts.find(r=>r.taskId===t);if(o){const r=o.nodes.find(n=>n.id===e);if(r){r.inputs||(r.inputs=[]);const n={id:`input-${Date.now()}`,name:a,description:i,required:s};r.inputs.push(n),await this.updateFlowchart(t,o)}}}async updateNodeInput(t,e,a,i){const s=this.taskFlowcharts.find(o=>o.taskId===t);if(s){const o=s.nodes.find(r=>r.id===e);if(o&&o.inputs){const r=o.inputs.find(n=>n.id===a);r&&(Object.assign(r,i),await this.updateFlowchart(t,s))}}}async deleteNodeInput(t,e,a){const i=this.taskFlowcharts.find(s=>s.taskId===t);if(i){const s=i.nodes.find(o=>o.id===e);s&&s.inputs&&(s.inputs=s.inputs.filter(o=>o.id!==a),await this.updateFlowchart(t,i))}}getItems(t){return this.items.filter(e=>!t||e.type===t)}getItemCount(t){return this.items.filter(e=>e.type===t).length}getFiles(){return this.files}getFileCount(){return this.files.length}buildFileTree(){const t=this.getFiles(),e=[];for(const i of t){const s=i.path.split("/");let o=e;for(let r=0;r<s.length;r++){const n=s[r],f=r===s.length-1,w=s.slice(0,r+1).join("/");let p=o.find(m=>m.name===n);if(!p){const m={name:n,path:w,isDirectory:!f,file:f?i:void 0};f||(m.children=[]),o.push(m),p=m}!f&&p.children&&(o=p.children)}}const a=i=>{i.sort((s,o)=>s.isDirectory&&!o.isDirectory?-1:!s.isDirectory&&o.isDirectory?1:s.name.localeCompare(o.name)),i.forEach(s=>{s.children&&a(s.children)})};return a(e),e}toggleFilePath(t){this.expandedFilePaths.has(t)?this.expandedFilePaths.delete(t):this.expandedFilePaths.add(t),this.saveExpandedState()}isFilePathExpanded(t){return this.expandedFilePaths.has(t)}toggleSection(t){this.expandedSections.has(t)?this.expandedSections.delete(t):this.expandedSections.add(t),this.saveExpandedState()}isSectionExpanded(t){return this.expandedSections.has(t)}async createItem(t,e){const a=`${t}-${Date.now()}`;let i,s;switch(t){case"task":i=_,s=`workspace://tasks/${a}`;break;case"agent":i=N,s=`workspace://agents/${a}`;break;case"conversation":i=T,s=`workspace://conversations/${a}`;break}await this.client.callMCPTool("create_resource",{payload:{uri:s,name:e,mimeType:i}});const o={id:a,workspaceId:this.workspaceId,type:t,title:e,created:new Date().toISOString(),status:"active"};return this.items=[...this.items,o],o}async updateItem(t,e){const a=this.items.findIndex(r=>r.id===t);if(a===-1)throw new Error("Item not found");const i=this.items[a];let s;switch(i.type){case"task":s=`workspace://tasks/${t}`;break;case"agent":s=`workspace://agents/${t}`;break;case"conversation":s=`workspace://conversations/${t}`;break}await this.client.callMCPTool("update_resource",{payload:{uri:s,...e.title&&{name:e.title}}});const o={...i,...e};return this.items=[...this.items.slice(0,a),o,...this.items.slice(a+1)],o}async deleteItem(t){const e=this.items.find(i=>i.id===t);if(!e)throw new Error("Item not found");let a;switch(e.type){case"task":a=`workspace://tasks/${t}`;break;case"agent":a=`workspace://agents/${t}`;break;case"conversation":a=`workspace://conversations/${t}`;break}await this.client.callMCPTool("delete_resource",{payload:{uri:a}}),this.items=this.items.filter(i=>i.id!==t)}close(){this.unwatchResources&&(this.unwatchResources(),this.unwatchResources=void 0),this.saveExpandedState(),this.items=[],this.files=[],this.taskFlowcharts=[],this.expandedSections.clear(),this.expandedFilePaths.clear(),this.isLoading=!1}loadExpandedState(){try{const t=localStorage.getItem(`nanobot-expanded-sections-${this.workspaceId}`);t&&JSON.parse(t).forEach(i=>this.expandedSections.add(i));const e=localStorage.getItem(`nanobot-expanded-file-paths-${this.workspaceId}`);e&&JSON.parse(e).forEach(i=>this.expandedFilePaths.add(i))}catch(t){console.error("Failed to load expanded state:",t)}}saveExpandedState(){try{localStorage.setItem(`nanobot-expanded-sections-${this.workspaceId}`,JSON.stringify([...this.expandedSections])),localStorage.setItem(`nanobot-expanded-file-paths-${this.workspaceId}`,JSON.stringify([...this.expandedFilePaths]))}catch(t){console.error("Failed to save expanded state:",t)}}}class O{client;constructor(t){this.client=t?.client||new C}async listWorkspaces(){const t=await this.client.listResources({prefix:"nanobot://workspaces/"});if(!t.resources)return[];const e=[];for(const a of t.resources)if(a.uri?.startsWith("nanobot://workspaces/")&&a.mimeType===L)try{const s={id:a.uri.split("/").pop()||"",name:a.name,created:a.annotations?.lastModified||"",icons:a.icons},o=a._meta?.["ai.nanobot"];o&&(typeof o.order=="number"&&(s.order=o.order),typeof o.color=="string"&&(s.color=o.color)),e.push(s)}catch(i){console.error("Failed to parse workspace resource:",i)}return e}async createWorkspace(t){return await this.client.callMCPTool("create_workspace",{payload:t})}async updateWorkspace(t,e){return await this.client.callMCPTool("update_workspace",{payload:{uri:`nanobot://workspaces/${t}`,...e}})}async deleteWorkspace(t){await this.client.callMCPTool("delete_workspace",{payload:{uri:`nanobot://workspaces/${t}`}})}}new O;class B{#s=h(u([]));get workspaces(){return c(this.#s)}set workspaces(t){l(this.#s,t,!0)}#t=h(u(new k));get expandedWorkspaceIds(){return c(this.#t)}set expandedWorkspaceIds(t){l(this.#t,t,!0)}#e=h(!1);get isLoading(){return c(this.#e)}set isLoading(t){l(this.#e,t,!0)}itemStoreCache=new Map;service;constructor(t){this.service=t?.service||new O,this.loadExpandedState()}getItemStore(t){let e=this.itemStoreCache.get(t);return e||(e=new Y(t),this.itemStoreCache.set(t,e)),e}clearItemStore(t){const e=this.itemStoreCache.get(t);e&&(e.close(),this.itemStoreCache.delete(t))}async load(){this.isLoading=!0;try{this.workspaces=await this.service.listWorkspaces()}catch(t){console.error("Failed to load workspaces:",t),this.workspaces=[]}finally{this.isLoading=!1}}toggleWorkspace(t){this.expandedWorkspaceIds.has(t)?this.expandedWorkspaceIds.delete(t):this.expandedWorkspaceIds.add(t),this.saveExpandedState()}isWorkspaceExpanded(t){return this.expandedWorkspaceIds.has(t)}async createWorkspace(t){const e=await this.service.createWorkspace({name:t,order:this.workspaces.length});return this.workspaces=[...this.workspaces,e],e}async updateWorkspace(t,e){const a=this.workspaces.findIndex(n=>n.id===t);if(a===-1)throw new Error("Workspace not found");const{id:i,created:s,...o}=e,r=await this.service.updateWorkspace(t,o);return this.workspaces=[...this.workspaces.slice(0,a),r,...this.workspaces.slice(a+1)],r}async deleteWorkspace(t){await this.service.deleteWorkspace(t),this.workspaces=this.workspaces.filter(e=>e.id!==t),this.clearItemStore(t),this.expandedWorkspaceIds.delete(t),this.saveExpandedState()}loadExpandedState(){try{const t=localStorage.getItem("nanobot-expanded-workspaces");t&&JSON.parse(t).forEach(a=>this.expandedWorkspaceIds.add(a))}catch(t){console.error("Failed to load expanded state:",t)}}saveExpandedState(){try{localStorage.setItem("nanobot-expanded-workspaces",JSON.stringify([...this.expandedWorkspaceIds]))}catch(t){console.error("Failed to save expanded state:",t)}}}const et=new B;export{Q as B,X as L,Z as P,tt as p,et as w};
